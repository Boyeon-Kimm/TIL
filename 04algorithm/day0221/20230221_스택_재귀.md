# 2023.02.21

# APS기본 - 스택(Stack) & 큐(Queue)

### 계산기

- 문자열로 된 계산식이 주어질 때, 스택을 이용하여 이 계산식의 값을 계산할 수 있다.
- 문자열 수식 계산의 일반적 방법
    - **step 1. 중위 표기법의 수식을 후위 표기법으로 변경한다. - 연산자의 스택**
        - 중위표기법 : infix notation 연산자를 피연산자의 가운데 표기하는 방법 `A+B`
            - 수식의 각 연산자에 대해서 우선순위에 따라 괄호를 사용하여 다시 표현한다
            - 각 연산자를 그에 대응하는 오른쪽 괄호의 뒤로 이동시킨다
            - 괄호를 제거한다
    
    ```java
    ex ) A * B - C / D
    
    1단계 : (( A * B ) - ( C / D ))
    2단계 : (( A B ) * ( C D ) / )-
    3단계 : A B * C D /-
    ```
    
    | 우선순위 | 연산자 | 결합의 방향 |
    | --- | --- | --- |
    | 1 | ( ) |  |
    | 2 | ^ | R → L |
    | 3 | * / / | L → R |
    | 4 | + / - | L → R |
    - step 2. 중위 표기법에서 후위 표기법으로의 변환 **알고리즘(스택 이용)2**
        1. 입력 받은 중위 표기식에서 토큰을 읽는다.
        2. 토큰이 피연산자이면 토큰을 출력한다.
        3. 토큰이 연산자(괄호포함)일 때, 이 토큰이 스택의 top에 저장되어 있는 연산자보다 우선순위가 높으면 스택에 push하고, 그렇지 않다면 스택 top의 연산자이 우선순위가 토큰의 우선순위보다 작을 때까지 스택에서 pop한 후 토큰의 연산자를 push한다. 만약 top에 연산자가 없으면 push한다.
        4. 토큰이 오른쪽 괄호 `)` 이면 스택 top에 왼쪽 괄호 `(` 가 올 때까지 스택에 pop 연산을 수행하고 pop한 연산자를 출력한다. 왼쪽 괄호를 만나면 pop만 하고 출력하지는 않는다.
        5. 중위 표기식에 더 읽을 것이 없다면 중지하고, 더 읽을 것이 있다면 1부터 다시 반복한다.
        6. 스택에 남아있는 연산자를 모두 pop하여 출력한다.
            1. 스택 밖의 왼쪽 괄호는 우선 순위가 가장 높으며, 스택 안의 왼쪽 괄호는 우선순위가 가장 낮다.
            
    - **step 2. 후위 표기법의 수식을 스택을 이용하여 계산한다. - 피연산자의 스택**
        - 후위표기법 : postfix notation 연산자를 피연산자 뒤에 표기하는 방법 `AB+`
        1. 피연산자를 만나면 스택에 push한다.
        2. 연산자를 만나면 필요한 만큼의 피연산자를 스택에서 pop하여 연산하고, 연산결과를 다시 스택에 push한다.
        3. 수식이 끝나면, 마지막으로 스택을 pop하여 출력한다.
        

# 재귀호출

### 특징

- 再 다시 재, 歸 돌아갈 귀
- 자기 자신을 호출하여 순환 수행되는 것
- 함수 호출은 메모리 구조에서 스택을 사용한다.(이름만 같은 다른 메서드)
    - 간단한 문제에 대해서는 반복문에 비해 메모리 및 속도에서 성능저하가 발생
- 일반적으로 기본 부분(Base case), 재귀 부분(Recursive case)로 구성된다
    - Base case : 재귀 호출에서 빠져 나가기 위한 조건
    - Recursive case : 자신을 호출하는 부분(Base case로 유도한다.)
- 재귀적 프로그램을 작성하는 것은 반복 구조에 비해 간결하고 이해하기 쉽다.
- 함수에서 실행해야 하는 작업의 특성에 따라 일반적인 호출방식보다 재귀호출방식을 사용하여 함수를 만들면 프로그램의 크기를 줄이고 간단하게 작성
    - 재귀호출의 예 ) factorial
        - -n에 대한 factorial : 1부터 n까지의 모든 자연수를 곱하여 구하는 연산
        
        ```
        n! = n x (n-1)!
        	(n-1)! = (n-1) x (n-2)!
        	(n-2)! = (n-2) x (n-3)!
        
        	...
        	
        	2! = 2 x 1!
        	1! = 1
        ```
        
        - 마지막에 구한 하위 값을 이용하여 상위 값을 구하는 작업을 반복

### 피보나치

- 0과 1로 시작하고 이전의 두 수 합을 다음 항으로 하는 수열
    - 0, 1, 1, 2, 3, 5, 8, 13 ..
- 피보나치 수열의 i번 째 값을 계산하는 함수 F를 정의하면 다음과 같다.
    - F0 = 0, F1 = 1
    - Fi = Fi-1 + Fi-2 for i ≥ 2
- 위의 정의로부터 피보나치 수열의 i번째 항을 반환하는 함수를 재귀함수로 구현할 수 있다.
- 피보나치 수를 구하는 재귀함수

```java
public static int fibo(int n){
	if(n <= 1) {
		return n;
	} else {
		return fibo(n - 1) + fibo(n - 2);
	}
}
```

- 앞의 예에서 피보나치 수를 구하는 함수를 재귀함수로 구현한 알고리즘은 문제점이 있다.
- “엄청난 중복 호출이 존재한다”는 것이다.
- 피보나치 수를 구하는 알고리즘에서 fibo(n)의 값을 계산하자마자 저장하면(memoize), 실행시간을 0(n)줄일 수 있다.
- Memoization 방법을 적용한 알고리즘은 다음과 같다.

```java
// memo를 위한 배열을 할당하고, 모두 0으로 초기화 한다;
// memo[0]을 0으로 memo[1]은 1로 초기화 한다;

public static int mFibo(int n){
	if(n >= 2 && memo[n] == 0){
		memo[n] = mFibo(n - 1) + mFibo(n - 2);
	}
	return memo[n];
}
```