# 2023.04.05

# APS - Computational Thinking

## 프로그래밍과 논리 / 수학

### 프로그래밍의 어려운 점 두가지

- 프로그래밍 언어 문법과 라이브러리 사용
- 논리 Hard Logic

<br>

<br>

### 문법과 라이브러리

- 많이 알려진 어려운 점
- 위 프로그램이 무엇을 하는 것인지 처음 보는 사람은 알 수 없다

<br>

<br>

### Hard vs Soft Logic

- 직관은 논리적인 느낌을 주는 것
- 직관의 장점은 (익숙한 상황에서) 빠르다는 것
- 직관의 단점은 정확하지 않다는 것(가끔은 익숙한 상황에서도 틀림)
- 또 다른 단점은 강한 착각을 일으킨다는 것

<br>

<br>

### 일상 생활에서는

- Soft Logic이 빠르기 때문에 유용
- 논리적으로 부정확한 표현을 사용하지만 어떤 의미인지 모든 사람이 이미 알고 있다는 가정이 존재

<br>
<br>

### 프로그래밍은 Hard Logic을 사용

- 프로그래밍 언어의 표현들이 모두 논리학에서 나온 것
- 사용되는 수 많은 알고리즘들을 이해하기 위해서는 Hard Logic이 필요

<br>
<br>

### 오해의 근원

- Soft Logic으로 알고리즘을 이해하려고 하는 것
- 알고리즘 설명을 보고 또 봐도 이해가 안되는 것은 증명을 안 봤기 때문
- 증명을 봐도 이해가 안 되는 것은 직관으로 이해하려고 하기 때문
- 가끔 직관적으로 이해하는 알고리즘이 있지만 조금만 어려워지면 직관으로 완전한 이해를 얻는 것은 사실상 불가능

<br>
<br>

### 명제

- 참이나 거짓을 알 수 있는 식이나 문장
- p, q, r, …로 표현
- ex ) 서울은 대한민국의 수도이다

<br>

<br>

### 진릿값

- 참이나 거짓을 표현
- T, F 또는 1, 0

<br>
<br>

### 부정 NOT [연산(결합)]

- p가 명제일 때, 명제의 진릿값이 반대
- ~p로 표기

<br>
<br>

### 논리곱 AND

- p, q가 명제일 때, p, q 모두 참일 때만 참이 되는 명제
- p ^ q( p and q, p 그리고 q)

<br>

<br>

### 논리합 OR

- p, q가 명제일 때, p, q 모두 거짓일 때만 거짓이 되는 명제
- p V q (p or q, p 또는 q)

<br>

<br>

### 배타적 논리합 XOR

- p, q가 명제일 때, p, q 중 하나만 참일 때 참이 되는 명제
- p + q (p xor q)

<br>

<br>

### [합성]

- 연산자 우선순위
    - ㄱ > V, ^ > → , ↔
- 항진명제 : 진릿값이 항상 참
- 모순명제 : 진릿값이 항상 거짓
- 사건명제 : 항진명제도 모순명제도 아닌 명제

<br>

<br>

### 조건명제

- p, q가 명제일 때, 명제 p가 조건(또는 원인), q가 결론(또는 결과)로 제시되는 명제
- p → q (p이면 q이다)

<br>

<br>

### 쌍방조건명제

- p, q가 명제일 때, 명제 p와 q가 모두 조건이면서 결론인 명제
- p ↔ q (p면 q고, q면 p다.)

<br>
<br>

### 조건명제의 역, 이, 대우

- 역 : q → p
- 이 : ㄱp → ㄱq
- 대우 : ㄱq → ㄱp

<br>

<br>

### 증명

- 증명은 정확한 명제식으로 표현할 수 있는 것이어야 함
- 보통은 정확한 명제식까지 쓰지는 않으나 근본적으로는 명제식으로 바꿀 수 있음
- 증명에 대한 수많은 오해가 p → q를 p ↔ q와 혼동하는 것에서 일어남