# 2023.03.28

# APS - 그래프(Graph)

## 그래프 탐색

### A로부터 시작해서 한 명의 친구에게만 소식을 전달, 전달 할 수 있다면 최대 몇 명의 친구가 소식을 전달받을 수 있을까? ( 단 , 소식을 전달 받은 친구한테는 소식을 재전달 할 수 없다.)

<br>

<br>

### A로부터 시작해서 친구들에게 동시에 소식을 전달할 수 있다고 할 때, 가장 늦게 전달받는 사람은 누구일까? (단 친구에게 소식을 전달하는 속도는 동일하다)

<br>

<br>

### 트리(그래프, 2차원 배열) 순회(탐색)는 모든 자료(노드, 정점)을 빠짐 없이 탐색하는 것을 의미한다

<br>
<br>

### 두 가지 방법

- 깊이 우선 탐색(Depth First Search, DFS)
- 너비 우선 탐색(Breadth First Search, BFS)

<br>

<br>

## 깊이 우선 탐색(Depth First Search)

### 루트 노드(시작 정점, 출발 위치)에서 출발하여 한 방향으로 갈 수 있는 경로가 있는 곳까지 깊이 탐색해 가다가 더 이상 갈 곳이 없게 되면, 가장 마지막에 만났던 갈림길 간선이 있는 노드(정점)로 되돌아와서 다른 방향의 노드(정점)으로 탐색을 계속 반복하여 결국 모든 노드(정점)을 방문하는 순회방법

<br>

<br>

### 가장 마지막에 만났던 갈림길의 노드(정점)로 되돌아가서 다시 깊이 우선 탐색을 반복해야 하므로 후입선출(LIFO : Last-In-First-Out)자료구조인 스택(Stack)사용

<br>

<br>

### 재귀 함수는 시스템 스택을 이용하므로 이를 이용하여 간단하게 구현할 수도 있음.

<br>
<br>

### 탐색 방법(Stack)

- 루트 노드 stack push
- stack 공백상태가 될 때까지 반복
    - stack에서 노드(curr) pop
    - curr의 모든 자식 노드 stack push

```java
DFS(v){  // v : 루트 노드
	stack.push(v)
	while(not stack.imEmpty){
		curr = stack.pop
		for w in (curr의 모든 자식)
			stack.push(w)
	}
}
```

<br>
<br>

### 탐색 방법(재귀 함수)

- 현재 노드 (v) 방문
- (v) 의 자식 노드 (w)를 차례로 재귀 호출

```java
DFS(v){
	v 방문;
	for w in (v의 모든 자식){
		DFS(w);
	}
}

// G : 그래프, visited : 방문 배열
DFS(v) {
	visited[v] <- TRUE // v 방문 설정

	FOR each all w in adjacency(G, v)
		IF visited[w] != TRUE
			DFS(w)
}

// 2차원 배열에서의 DFS
// arr : 2차원 배열, visited : 방문 배열
DFS(r, c) {
	visited[r][c] <- TRUE // v 방문 설정
	
	FOR (r, c) 를 기준으로 4방향 탐색
		IF 다음 좌표는 이동 가능한 것인지 체크
			DFS(nr, nc)
}
```

<br>

<br>

<br>

## 너비 우선 탐색(Breadth First Search, BFS)

### 너비 우선 탐색은 탐색 루트 노드(시작 정점, 출발 위치)의 자식 노드(인접한 정점)들을 먼저 모두 차례로 방문한 후에 방문했던 자식 노드들(인접한 정점)을 시작점으로 하여 다시 해당 노드의 자식 노드(인접한 정점)들을 차례로 방문하는 방식

<br>

<br>

### 자식 노드(인접한 정점)들에 대해 탐색을 한 후, 차례로 다시 너비 우선 탐색을 진행해야 하므로, 선입선출(FIFO : First-In-First-Out) 형태의 자료구조인 큐를 활용함

<br>

<br>

### 너비 우선 탐색은 인접한 노드들부터 차례대로 방문을 하므로 시작 정점과 끝 정점이 주어졌을 때 최단 길이를 구할 수 있음

<br>

<br>

### 🌟 최단길이를 구하라는 말이 있으면 BFS 사용하기! 🌟

- DFS 사용해도 가능하지만 BFS를 더 고려하기

<br>

<br>

### 탐색 방법

- 루트 노드 Queue에 삽입
- Queue가 공백이 될 때까지 반복 수행
    - Queue에서 원소(curr)꺼내기
    - 해당 원소 방문
    - curr의 자식 노드 Queue에 삽입

```java
BFS(v){
	Queue 생성;
	Queue.add(v);
	WHILE (!Queue.isEmpty()){
		curr <- Queue.dep();
		curr 방문
		FOR w (curr의 모든 자식 노드)
			Queue.add(w)
	}
}

// G : 그래프, v : 탐색 시작점
BFS(G, v)
	큐 생성
	시작점 v를 큐에 삽입
	점 v를 방문한 것으로 표시 ⭐
	WHILE 큐가 비어있지 않은 경우
		t <- 큐의 첫번째 원소 반환
		FOR t와 연결된 모든 선에 대해
			u <- t의 이웃점
			u가 방문되지 않은 곳이면,
			u를 큐에 넣고, 방문 것으로 표시 ⭐
```