# 2023.04.10

# APS - DP(Dynamic Programming)

## 피보나치 수열

### 0과 1로 시작하고 이전 두 수의 합을 다음 항으로 하는 수열을 피보나치 수열이라고 한다

- 0, 1, 1, 2, 3, 5, 8, 13

<br>

<br>

### 피보나치 수열의 i번째 값을 계산하는 함수 F를 정의하면 다음과 같다

- F0 = =, F1 = 1
- Fi = Fi-1 + Fi-2 for i ≥ 2

<br>

<br>

### 위의 정의로부터 피보나치 수열의 i번째 항을 반환하는 함수를 재귀함수로 구현할 수 있다

```java
fibo(n)
	IF n < 2 : RETURN n
	ELSE : RETURN fibo(n - 1) + fibo(n - 2)
```

<br>

<br>

## Memoization

### 메모이제이션은 컴퓨터 프로그램을 실행할 때, 이전에 계산한 값을 메모리에 저장해서 매번 다시 계산하지 않도록 하여 전체적인 실행속도를 빠르게 하는 기술이다

<br>

<br>

### 동적 계획법의 핵심이 되는 기술이다

<br>

<br>

### ‘memoization’은 글자 그대로 해석하면 ‘메모리에 넣기(to put in memory)’라는 의미이며 ‘기억되어야 할 것’ 이라는 뜻의 라틴어 memorandum에서 파생되었다

<br>

<br>

### 흔히 ‘기억하기’, ‘암기하기’라는 뜻의 memorization과 혼동하지만 정확한 단어는 memoization이다.

<br>

<br>

### 동사형은 memoize이다.

<br>

<br>

### 피보나치 수를 구하는 알고리즘에서 fibo(n)의 값을 계산하자마자 저장하면 실행시간은 O(n)

<br>

<br>

### Memoization 방법을 적용한 알고리즘

```java
memo를 위한 배열을 할당하고, 모두 0으로 초기화한다
memo[0]을 0으로 memo[1]는 1로 초기화한다

fibo(n)
	IF n > 2 AND memo[n] = 0
		memo[n] <- fibo(n - 1) + fibo(n - 2)
	RETURN memo[n]
```

<br>

<br>

### 메모이제이션

- 추가적인 메모리 공간 필요
- 재귀 함수 호출로 인한 시스템 호출 스택을 사용 → 실행 속도 저하 또는 오버플로우가 발생할 수 있음

<br>

<br>

<br>

## 동적 계획 알고리즘

### 동적 계획(Dynamic Programming)알고리즘은 그리디 알고리즘과 같이 최적화 문제를 해결하는 알고리즘이다

<br>

<br>

### 최적화 문제 : 최적(최댓값이나 최솟값 같은) 값을 구하는 문제

- 해당 문제에 여러 해가 있을 수 있다
- 특정한 최적해를 구하는 것이 아니라 어떤 최적해를 구하는 것이다

<br>

<br>

### 동적 계획 알고리즘은 먼저 작은 부분 문제들의 해들을 구하고 이들을 이용하여 보다 큰 크기의 부분 문제들을 해결하여, 최종적으로 원래 주어진 문제를 해결하는 알고리즘 설계 기법이다.

<br>

<br>

### 동적 계획법을 적용하려는 문제는 필히 다음과 같은 요건을 가지고 있어야 한다

- 중복 부분문제 구조(Overlapping subproblems)
- 최적 부분문제 구조(Optimal substructure)

<br>
<br>

## 중복 부분문제 구조(Overlapping subproblems)

### DP는 큰 문제를 이루는 작은 문제들을 먼저 해결하고, 작은 문제들의 최적 해(Optimal Solution)을 이용하여 순환적으로 큰 문제를 해결한다

- 순환적인 관계(recurrence relation)를 명시적으로 표현하기 위해서 동적 계획법에서는 일반적으로 수학적 도구인 점화식을 사용한다

<br>
<br>

### DP는 문제의 순환적인 성질 때문에 이전에 계산되었던 작은 문제의 해가 다른 어딘가에서 필요하게 되는데 이를 위해 DP에서는 이미 해결된 작은 문제들의 해들을 어떤 저장 공간(Table)에 저장하게 된다

<br>
<br>

### 그리고 이렇게 저장된 해들이 다시 필요할 때마다 해를 얻기 위해 다시 문제를 재계산하지 않고, table의 참조를 통해서 중복된 계산을 피하게 된다

<br>
<br>

## 최적 부분문제 구조(Optimal substructure)

### 동적 계획법이 최적화에 대한 어느 문제에나 적용될 수 있는 것은 안디ㅏ

<br>
<br>

### 주어진 문제가 최적화의 원칙(Principle of Optimality)을 만족해야만 동적 계획법을 효율적을 적용

<br>
<br>

### 최적화의 원칙이란 어떤 문제에 대한 해가 최적일 때, 그 해를 구성하는 작은 문제들의 해 역시 최적이어야한다는 것

<br>
<br>

### 동적 계획법의 방법 자체가 큰 문제의 최적 해를 작은 문제의 최적해들을 이용하여 구하기 때문에 만약 큰 문제의 최적해가 작은 문제들의 최적해들로 구성되지 않는다면 이 문제는 동적 계획법을 적용할 수 없다.

<br>
<br>

### 최적의 원칙이 적용되지 않는 예 : 최장경로(Longest Path)문제

- A에서 D로의 최장 경로는 [A, C, B, D]가 된다
- 그러나 이 경로의 부분 경로인 A에서 C로 최장 경로는 [A, C]가 아니라 [A, B, C]이다
- 최적의 원칙이 적용되지 않는다
- 따라서 최장 경로 문제는 DP로 해결할 수 없다

<br>
<br>

### 분할 정복과 동적 계획법의 비교

### 분할 정복

- 연관 없는 부분 문제로 분할 한다
- 부분 문제를 재귀적으로 해결한다
- 부분문제의 해를 결합(Combine)한다
- ex : 병합 정렬 / 퀵정렬

<br>
<br>

### DP

- 부분 문제들이 연관이 없으면 적용할 수 없다.
    - 즉, 부분 문제들은 더 작은 부분 문제들을 공유한다)
- 모든 부분 문제를 한 번만 계산하고, 결과를 저장하고 재 사용한다
    - 분할 정복은 같은 부분 문제가 나타날 경우 다시 계산한다.

<br>
<br>

### DP에는 부분 문제들 사이에 의존적 관계가 존재한다

<br>
<br>

### 이러한 관계는 문제에 따라 다르고, 대부분의 경우 뚜렷이 보이지 않아서 함축적인 순서(Implicit order)라고 한다

<br>
<br>

### 분할 정복은 하향식 방법으로, DP는 상향식 방법으로 접근한다

<br>
<br>

### 3단계 DP 적용 접근 방법

1. 최적해 구조의 특성을 파악하라
    1. 문제를 부분 문제로 나눈다
2. 최적해의 값을 재귀적으로 정의하라
    1. 부분 문제의 최적해 값에 기반하여 문제의 최적해 값을 정의한다
3. 상향식 방법으로 최적해의 값을 계산하라
    1. 가장 작은 부분 문제부터 해를 구한 뒤 테이블에 저장한다
    2. 테이블에 저장되어 있는 부분 문제의 해를 이용하여 점차적으로 상위 부분 문제의 최적해를 구한다(상향식 방법)

<br>
<br>

## 피보나치 수 DP 적용

### 피보나치 수는 부분 문제의 답으로부터 본 문제의 답을 얻을 수 있으므로 최적 부분 구조로 이루어져 있다

1. 문제를 부분 문제로 분할한다
2. 점화식으로 정의한다
3. 가장 작은 부분 문제부터 해를 구한다
4. 그 결과는 테이블에 저장하고 테이블에 저장된 부분 문제의 해를 이용하여 상위 문제의 해를 구한다.

```java
fibo_dp(n)
	f[0] <- 0
	f[1] <- 1
	FOR i in 2 -> n
		f[i] <- f[i - 1] + f[i - 2]
	RETURN f[n]

작은 문제ㅏ
```

<br>
<br>

## 피보나치 수 DP 적용 - 알고리즘 분석

### DP 알고리즘이 수행속도가 더 빠르다

<br>
<br>

### Why?

- 재귀 알고리즘과 달리 중복 계산이 없다
- 또한 반복문을 사용하기 때문에 함수 호출이 발생하지 않는다
- fibo_dp[0]부터 fibo_dp[n]까지 한번씩만 계산한다

<br>
<br>
<br>

## 배낭 문제(Knapsack)

```java
배낭의 용량W
n개의 물건과 각 물건 i의 무게 w와 가치 v, 단 i = 1, 2, ..., n
출력 : K[n, W]

FOR i in 0 -> n: K[i, 0] <- 0
FOR w in 0 -> W: K[0, w] <- 0

FOR i in 1 -> n
	FOR w in 1 -> W
		IF w > w
			K[i, w] <- K[i - 1, w]
		ELSE
			K[i, w] <- max(K[i - 1, w - wi] + v, K[i - 1, w])
RETURN K[n, W]
```